---
title: "New in 0.10.5"
---


```{r,include = FALSE,message=FALSE,warning=FALSE}
library(tidyverse)
library(mrgsolve)
knitr::opts_chunk$set(comment = '.')
```


# Introduction

This blog post shows some of the new features that came into mrgsolve starting
with version `0.10.5` (December 2020).  The purpose 
is to illustrate what is possible rather than detailed documentation.  

# Specify capture at compile time

__Big Idea__: The feature helps give you more flexibility for getting 
data out of your model and into your simulated output. 

In your mrgsolve model, you can request that the values of different variables
are written into the simulated output.  This is done through the capture block
or by declaring variables as type `capture`:

```{r}
mod <- mread("popexample.mod")
blocks(mod, MAIN, TABLE, CAPTURE)
```
Here we have derived several variables (`CL`, `V`, `KA`, `IPRED`, `DV`) and 
some of them have been marked for "capture" (`DV` and `CL`).  

We can check what will be captured:

```{r}
outvars(mod)
```

Starting with mrgsolve 0.10.5, you can specify additional variables for 
capture when you read in the model with `mread()`:

```{r}
mod <- mread("popexample.mod", capture = "ETA(1), WT, IPRED, V")
```
Here, I've asked for the value of one of the ETAs, a parameter (`WT`) and 
a couple of derived quantities (`IPRED` and `V`):

```{r}
outvars(mod)
```

And now when I simulate from the model, I'll get all of these quantities
back:
```{r}
mrgsim(mod)
```

This is temporary until the model is re-compiled again
```{r}
mread("popexample.mod") %>% outvars
```






# Smarter warnings when non-numeric columns are dropped

mrgsolve warns you when non-numeric columns are dropped from the data 
set when you run the model.  For example:


```{r, message = FALSE, warning = FALSE}
library(mrgsolve)

mod <- modlib("popex") %>% update(outvars = "IPRED")
```

In this model, we have the following parameters:
```{r}
param(mod)
```

Let's create an input data set with some character values: two 
parameter columns and one non-parameter column:
```{r}
data <- expand.ev(amt = 100, WT = "500", TVV = "ABC", name = "KYLE")
```


```{r}
mrgsim(mod, data)
```

Previously, mrgsolve would have warned you about all 3 columns; now 
it only warns you about columns that are dropped and would have been 
relevant to the simulation. 

This example is made up to illustrate the behavior.  But in typical usage when 
we do things right, we might have extra character columns that we don't care
about. In this case we get no warnings:

```{r}
data <- expand.ev(
  amt = 100, WT = 70, TVV = 20, name = "KYLE", 
  state = "minnesota"
)

mrgsim(mod, data)

```

Remember, we can still ask for non-numeric items to be brought into the 
data set with the `recover` argument:

```{r}
mrgsim(mod, data, recover = "name,state")
```

# `$ERROR`
There is a new block alias called `$ERROR` that is just an alias for `$TABLE`


```{r}
code <- '
$PARAM CL = 1, V = 20, KA = 1

$PKMODEL cmt = "CENT"

$ERROR
capture CP = CENT/V;
'
mod <- mcode("error", code)

mrgsim(mod)
```

# Try loading the model at runtime if it isn't loaded

Sometimes, you find yourself with a model object but the shared 
object hasn't been loaded into the session. This could happen when 
you are running simulations in parallel and the model doesn't get loaded
in the worker R process. For the post, I'll just phony up a model 
that happens to not be loaded:

This code loads and then unloads the model, and then shows that it is 
not loaded:

```{r}
mod <- modlib("pk1")
mrgsolve:::unloadso.mrgmod(mod)
mrgsolve:::funset(mod)
```
We can still simulate from this model; mrgsolve will determine that the 
model isn't loaded and it will try to load it for you.
```{r}
mrgsim(mod)
```

It's possible that the model can't be loaded (e.g. due to missing `.so` file). 
In that case, mrgsolve will give you the usual error message that the model
needs to be compiled.


# Time after dose in specific compartment

Version 0.10.5 also adds a new plugin with the ability to calculate 
time after dose in any compartment. 

```{r}
code <- '

[plugin] tad

[ global ] 
mrg::tadose tad_cmt_1(1); 
mrg::tadose tad_cmt_2(2);

[ pkmodel ] cmt = "GUT,CENT", depot = TRUE

[ param ] CL = 1, V = 20, KA = 1

[ main ] 
capture tad1 = tad_cmt_1.tad(self); 
capture tad2 = tad_cmt_2.tad(self);

'
  
mod <- mcode("tad", code, soloc = '.')


data <- c(
  ev(amt = 100, cmt = 1, time = 1), 
  ev(amt = 200, cmt = 2, time = 3)
)

mrgsim(mod, data)
  
  
```

Note that time after dose is -1 until a dose is administered. 

Recall also that time after dose can be calculated more simply if there is 
only one dose type by passing the `tad` argument:

```{r}
data1 <- filter(data, cmt ==1) %>% mutate(time = 3)
mod %>% mrgsim(data1, tad = TRUE)
```
 This is a little nicer because it will fill in negative `tad` values for you.
 















